name: "BookVerse Shared Build Workflow"


on:
  workflow_call:
    inputs:
      service-name:
        description: 'Service name (e.g., inventory, recommendations)'
        required: true
        type: string
      python-version:
        description: 'Python version to use'
        required: false
        type: string
        default: '3.11'
      skip-tests:
        description: 'Skip running tests'
        required: false
        type: boolean
        default: false
      skip-docker:
        description: 'Skip Docker image building'
        required: false
        type: boolean
        default: false
      create-app-version:
        description: 'Create AppTrust application version'
        required: false
        type: boolean
        default: true
    outputs:
      semver:
        description: 'Generated semantic version'
        value: ${{ jobs.build.outputs.semver }}
      build-name:
        description: 'JFrog build name'
        value: ${{ jobs.build.outputs.build-name }}
      build-number:
        description: 'JFrog build number'
        value: ${{ jobs.build.outputs.build-number }}

jobs:
  build:
    name: "Build & Publish: ${{ inputs.service-name }}"
    runs-on: ubuntu-latest
    
    outputs:
      semver: ${{ steps.semver.outputs.version }}
      build-name: ${{ steps.build-vars.outputs.build-name }}
      build-number: ${{ steps.build-vars.outputs.build-number }}
    
    steps:
      
      - name: "ğŸ“¥ Checkout Code"
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: "ğŸ Setup Python ${{ inputs.python-version }}"
        uses: actions/setup-python@v4
        with:
          python-version: ${{ inputs.python-version }}
      
      - name: "ğŸ”§ JFrog CLI Setup with OIDC (Pattern 1)"
        id: jfrog-cli-setup
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        env:
          JF_URL: ${{ vars.JFROG_URL }}
        with:
          oidc-provider-name: ${{ vars.OIDC_PROVIDER_NAME }}
          oidc-audience: ${{ vars.OIDC_AUDIENCE }}
      
      - name: "ğŸ” Manual OIDC Token Minting (Pattern 2)"
        id: manual-oidc
        run: |
          echo "ğŸ” Starting manual OIDC token minting for curl commands (${{ inputs.service-name }})"
          
          if [[ -z "$ACTIONS_ID_TOKEN_REQUEST_TOKEN" || -z "$ACTIONS_ID_TOKEN_REQUEST_URL" ]]; then
            echo "âš ï¸ Missing GitHub OIDC request environment variables"
            echo "   JFrog CLI OIDC is available, but manual tokens won't work"
            echo "manual_token_available=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          JF_URL="${{ vars.JFROG_URL }}"
          echo "ğŸ¯ Target JFrog Platform: $JF_URL"
          echo "ğŸ·ï¸ Service: ${{ inputs.service-name }}"
          echo "ğŸ”‘ OIDC Provider: ${{ vars.OIDC_PROVIDER_NAME }}"
          
          echo "ğŸ”„ Minting GitHub OIDC ID token for manual use..."
          GITHUB_TOKEN_RESPONSE=$(curl -sS -H "Authorization: bearer $ACTIONS_ID_TOKEN_REQUEST_TOKEN" \
            "$ACTIONS_ID_TOKEN_REQUEST_URL&audience=${{ vars.OIDC_AUDIENCE }}")
          
          GITHUB_OIDC_TOKEN=$(echo "$GITHUB_TOKEN_RESPONSE" | jq -r '.value // empty')
          if [[ -z "$GITHUB_OIDC_TOKEN" || "$GITHUB_OIDC_TOKEN" == "null" ]]; then
            echo "âŒ Failed to mint GitHub OIDC token for manual use"
            echo "   JFrog CLI OIDC is still available"
            echo "manual_token_available=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "ğŸ”„ Exchanging OIDC token for JFrog access token..."
          EXCHANGE_PAYLOAD=$(jq -n \
            --arg grant_type "urn:ietf:params:oauth:grant-type:token-exchange" \
            --arg subject_token_type "urn:ietf:params:oauth:token-type:id_token" \
            --arg subject_token "$GITHUB_OIDC_TOKEN" \
            --arg provider_name "${{ vars.OIDC_PROVIDER_NAME }}" \
            '{
              grant_type: $grant_type,
              subject_token_type: $subject_token_type,
              subject_token: $subject_token,
              provider_name: $provider_name
            }')
          
          JFROG_TOKEN_RESPONSE=$(curl -sS -X POST \
            -H "Content-Type: application/json" \
            -d "$EXCHANGE_PAYLOAD" \
            "$JF_URL/access/api/v1/oidc/token")
          
          JF_OIDC_TOKEN=$(echo "$JFROG_TOKEN_RESPONSE" | jq -r '.access_token // empty')
          if [[ -z "$JF_OIDC_TOKEN" || "$JF_OIDC_TOKEN" == "null" ]]; then
            echo "âŒ Failed to exchange OIDC token for manual use"
            echo "   JFrog CLI OIDC is still available"
            echo "manual_token_available=false" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          echo "JF_OIDC_TOKEN=$JF_OIDC_TOKEN" >> $GITHUB_ENV
          echo "JF_MANUAL_TOKEN=$JF_OIDC_TOKEN" >> $GITHUB_ENV
          
          echo "ğŸ§ª Testing manual token with JFrog API..."
          PING_RESPONSE=$(curl -sS -H "Authorization: Bearer $JF_OIDC_TOKEN" \
            "$JF_URL/artifactory/api/system/ping")
          
          if [[ "$PING_RESPONSE" == "OK" ]]; then
            echo "âœ… Manual OIDC token exchange successful and validated"
            echo "manual_token_available=true" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ Manual token obtained but validation failed"
            echo "manual_token_available=false" >> $GITHUB_OUTPUT
          fi
      
      - name: "ğŸ“‹ OIDC Setup Summary"
        run: |
          echo "ğŸ“‹ OIDC Authentication Summary for ${{ inputs.service-name }}"
          echo "=============================================="
          echo ""
          echo "ğŸ”§ PATTERN 1 - JFrog CLI with OIDC:"
          if [[ "${{ steps.jfrog-cli-setup.conclusion }}" == "success" ]]; then
            echo "   âœ… JFrog CLI configured with OIDC"
            echo "   âœ… Available: jf rt upload, jf rt ping, jf docker push, etc."
            echo "   âœ… No manual token needed for JFrog CLI commands"
          else
            echo "   âŒ JFrog CLI OIDC setup failed"
          fi
          
          echo ""
          echo "ğŸ” PATTERN 2 - Manual OIDC Tokens for Curl:"
          if [[ "${{ steps.manual-oidc.outputs.manual_token_available }}" == "true" ]]; then
            echo "   âœ… Manual tokens available for curl commands"
            echo "   âœ… Available: \$JF_OIDC_TOKEN, \$JF_MANUAL_TOKEN"
            echo "   âœ… Usage: curl -H \"Authorization: Bearer \$JF_OIDC_TOKEN\" ..."
          else
            echo "   âš ï¸ Manual tokens not available (JFrog CLI still works)"
            echo "   â„¹ï¸ Use JFrog CLI commands instead of direct curl"
          fi
          
          echo ""
          echo "ğŸ¯ Both OIDC patterns are now available in subsequent steps"
      
      - name: "ğŸ“¦ Install Dependencies"
        run: |
          echo "ğŸ“¦ Installing Python dependencies for ${{ inputs.service-name }}"
          pip install --upgrade pip
          pip install PyYAML
          
          jf pip-config --repo-resolve="${{ vars.PROJECT_KEY }}-pypi-virtual"
          
          if [ -f "requirements.txt" ]; then
            echo "Installing from requirements.txt..."
            jf pip install -r requirements.txt || pip install -r requirements.txt
          fi
          
          if [ -f "requirements-dev.txt" ]; then
            echo "Installing dev dependencies..."
            jf pip install -r requirements-dev.txt || pip install -r requirements-dev.txt
          fi
          
          echo "âœ… Dependencies installed successfully"
      
      
      - name: "ğŸ·ï¸ Determine Semantic Version"
        id: semver
        run: |
          echo "ğŸ·ï¸ Determining semantic version for ${{ inputs.service-name }}"
          
          
          if [ -f "scripts/semver_versioning.py" ]; then
            echo "ğŸ“‹ Using consolidated semver script from bookverse-devops"
            python scripts/semver_versioning.py \
              --application-key "${{ vars.PROJECT_KEY }}-${{ inputs.service-name }}" \
              --version-map "./config/version-map.yaml" \
              --jfrog-url "${{ vars.JFROG_URL }}" \
              --jfrog-token "${{ env.JF_OIDC_TOKEN }}" \
              --project-key "${{ vars.PROJECT_KEY }}" || {
                echo "âš ï¸ Consolidated semver script failed, using fallback"
                VERSION="1.0.$(git rev-list --count HEAD)"
                echo "version=$VERSION" >> $GITHUB_OUTPUT
                echo "âœ… Fallback version: $VERSION"
              }
          else
            echo "ğŸ“‹ Semver scripts not available, using simple versioning"
            
            VERSION="1.0.$(git rev-list --count HEAD)"
            echo "version=$VERSION" >> $GITHUB_OUTPUT
            echo "âœ… Generated version: $VERSION (demo fallback)"
          fi
      
      - name: "ğŸ”¨ Setup Build Variables"
        id: build-vars
        run: |
          BUILD_NAME="${{ inputs.service-name }}"
          BUILD_NUMBER="${{ github.sha }}"
          
          echo "build-name=$BUILD_NAME" >> $GITHUB_OUTPUT
          echo "build-number=$BUILD_NUMBER" >> $GITHUB_OUTPUT
          
          echo "JFROG_CLI_BUILD_NAME=$BUILD_NAME" >> $GITHUB_ENV
          echo "JFROG_CLI_BUILD_NUMBER=$BUILD_NUMBER" >> $GITHUB_ENV
          echo "JFROG_CLI_BUILD_PROJECT=${{ vars.PROJECT_KEY }}" >> $GITHUB_ENV
          
          echo "âœ… Build variables configured"
          echo "ğŸ“‹ Build Name: $BUILD_NAME"
          echo "ğŸ“‹ Build Number: $BUILD_NUMBER"
      
      
      - name: "ğŸ§ª Run Tests with Coverage"
        if: ${{ !inputs.skip-tests }}
        run: |
          echo "ğŸ§ª Running tests for ${{ inputs.service-name }}"
          
          if [ -f "pytest.ini" ] || [ -f "pyproject.toml" ]; then
            python -m pytest tests/ -v --cov=app --cov-report=term-missing --cov-report=xml
            echo "âœ… Tests completed with coverage report"
          else
            echo "âš ï¸ No pytest configuration found, running basic tests"
            python -m pytest tests/ -v || echo "No tests found or test failures"
          fi
      
      
      - name: "ğŸ“¦ Build Python Package"
        run: |
          echo "ğŸ“¦ Building Python package for ${{ inputs.service-name }}"
          
          if [ -f "pyproject.toml" ]; then
            pip install build
            python -m build
            echo "âœ… Built wheel package"
          else
            python setup.py sdist bdist_wheel || echo "No Python package to build"
          fi
          
          if [ -d "dist" ]; then
            echo "ğŸ“‹ Built artifacts:"
            ls -la dist/
          fi
      
      - name: "ğŸ³ Build Docker Image"
        if: ${{ !inputs.skip-docker }}
        run: |
          echo "ğŸ³ Building Docker image for ${{ inputs.service-name }}"
          
          if [ -f "Dockerfile" ]; then
            IMAGE_TAG="${{ vars.PROJECT_KEY }}-${{ inputs.service-name }}:${{ steps.semver.outputs.version }}"
            
            docker build -t "$IMAGE_TAG" .
            echo "âœ… Docker image built: $IMAGE_TAG"
            
            echo "docker-image=$IMAGE_TAG" >> $GITHUB_OUTPUT
          else
            echo "âš ï¸ No Dockerfile found, skipping Docker build"
          fi
      
      
      - name: "ğŸ“¤ Publish Artifacts"
        if: github.ref == 'refs/heads/main'
        run: |
          echo "ğŸ“¤ Publishing artifacts for ${{ inputs.service-name }}"
          
          REPO_BASE="${{ vars.PROJECT_KEY }}-${{ inputs.service-name }}-internal"
          
          if [ -d "dist" ] && [ "$(ls -A dist/)" ]; then
            echo "ğŸ“¦ Publishing Python packages..."
            jf rt upload "dist/*" "$REPO_BASE-python-nonprod-local/" --build-name="${{ steps.build-vars.outputs.build-name }}" --build-number="${{ steps.build-vars.outputs.build-number }}"
          fi
          
          if [ -f "Dockerfile" ] && [ ! "${{ inputs.skip-docker }}" = "true" ]; then
            echo "ğŸ³ Publishing Docker image..."
            IMAGE_TAG="${{ vars.PROJECT_KEY }}-${{ inputs.service-name }}:${{ steps.semver.outputs.version }}"
            jf docker push "$IMAGE_TAG" "$REPO_BASE-docker-nonprod-local" --build-name="${{ steps.build-vars.outputs.build-name }}" --build-number="${{ steps.build-vars.outputs.build-number }}"
          fi
          
          if [ -d "config" ] || [ -d "contracts" ] || [ -d "schemas" ]; then
            echo "ğŸ“„ Publishing configuration and schema files..."
            find . -name "*.json" -o -name "*.yaml" -o -name "*.yml" | grep -E "(config|contract|schema)" | while read file; do
              jf rt upload "$file" "$REPO_BASE-generic-nonprod-local/${{ inputs.service-name }}/" --build-name="${{ steps.build-vars.outputs.build-name }}" --build-number="${{ steps.build-vars.outputs.build-number }}"
            done
          fi
          
          echo "âœ… Artifacts published successfully"
      
      
      - name: "ğŸ“‹ Publish Build Info"
        if: github.ref == 'refs/heads/main'
        run: |
          echo "ğŸ“‹ Publishing build information"
          jf rt build-publish "${{ steps.build-vars.outputs.build-name }}" "${{ steps.build-vars.outputs.build-number }}"
          echo "âœ… Build info published"
      
      
      - name: "ğŸ›¡ï¸ Create AppTrust Application Version"
        if: ${{ inputs.create-app-version && github.ref == 'refs/heads/main' }}
        run: |
          echo "ğŸ›¡ï¸ Creating AppTrust application version"
          
          jf app create-version \
            --app-key="${{ vars.PROJECT_KEY }}-${{ inputs.service-name }}" \
            --version="${{ steps.semver.outputs.version }}" \
            --build-name="${{ steps.build-vars.outputs.build-name }}" \
            --build-number="${{ steps.build-vars.outputs.build-number }}" \
            --project="${{ vars.PROJECT_KEY }}"
          
          echo "âœ… AppTrust application version created"
      
      
      - name: "ğŸ“Š Build Summary"
        run: |
          echo "ğŸ‰ Build Complete for ${{ inputs.service-name }}"
          echo ""
          echo "ğŸ“‹ Build Details:"
          echo "   Service: ${{ inputs.service-name }}"
          echo "   Version: ${{ steps.semver.outputs.version }}"
          echo "   Build: ${{ steps.build-vars.outputs.build-name }}#${{ steps.build-vars.outputs.build-number }}"
          echo "   Python: ${{ inputs.python-version }}"
          echo "   Tests: ${{ inputs.skip-tests && 'Skipped' || 'Executed' }}"
          echo "   Docker: ${{ inputs.skip-docker && 'Skipped' || 'Built' }}"
          echo "   AppTrust: ${{ inputs.create-app-version && 'Created' || 'Skipped' }}"
          echo ""
          echo "âœ… Ready for promotion workflow"
